SOlution 1: timeout
cclass Solution:
    def longestPalindrome(self, s: str) -> str:
      longestPal=""
      ll = len(s)
      for i in range(ll):
        for j in range(ll,i,-1):
          if self.isNotPal(s[i:j],False) == False and (len(longestPal)<len(s[i:j])):
            longestPal = s[i:j]
            
      return longestPal
    
    
    
    
    
    def isNotPal (self, ss: str, notPal: bool):
      l = len(ss)
      if notPal == True :
        return notPal
      elif l == 0 : 
        notPal = False
        return notPal
      elif l>0 and ss[0]!=ss[l-1]:
        notPal = True
        return notPal 
      else:
        return self.isNotPal(ss[1:l-1],notPal)
      
      
          ----------------------------------
 Solution2
 
 class Solution:
  def longestPalindrome(self, s):
    res = ""
    for i in range(len(s)):
        # odd case, like "aba"
        tmp = self.helper(s, i, i)
        if len(tmp) > len(res):
            res = tmp
        # even case, like "abba"
        tmp = self.helper(s, i, i+1)
        if len(tmp) > len(res):
            res = tmp
    return res
  def helper(self, s, l, r):
    while l >= 0 and r < len(s) and s[l] == s[r]:
        l -= 1; r += 1
    return s[l+1:r]
